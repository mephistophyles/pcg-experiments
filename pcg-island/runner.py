import random
import sys

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import axes3d
import numpy as np


def generate_random_int_array(m, n, r, padded=True):
    # TODO maybe add distribution options like normal, uniform, weibull, etc found in numpy
    ar = np.zeros((m, n))
    for i in range(m):
        for j in range(n):
            if padded and (j == 0 or i == 0 or j == n-1 or i == m-1):
                continue
            ar[i][j] = random.randint(1, r)
    return ar


def neighbors(ar, m, n):
    if m % 2 == 0:
        return [ar[m/2][n/2], ar[m/2][n/2+1]]
    if n % 2 == 0:
        return [ar[m/2][n/2], ar[m/2+1][n/2]]
    else:
        return [ar[m/2][n/2], ar[m/2][n/2+1], ar[m/2+1][n/2], ar[m/2+1][n/2+1]]


def expand_int_array(ar, avg=True):
    m, n = ar.shape
    new_m = m*2-1
    new_n = n*2-1
    new_ar = np.zeros((new_m, new_n))
    for i in range(new_m):
        for j in range(new_n):
            if i % 2 == 0 and j % 2 == 0:
                new_ar[i][j] = ar[i/2][j/2]
            else:
                neighbor_values = neighbors(ar, i, j)
                weighted_neighbor = np.mean(neighbor_values)
                if avg:
                    if weighted_neighbor-np.floor(weighted_neighbor) == 0:
                        new_ar[i][j] = weighted_neighbor
                    else:
                        new_ar[i][j] = random.randint(np.floor(weighted_neighbor), np.ceil(weighted_neighbor))
                else:
                    new_ar[i][j] = random.choice(neighbor_values)

    return new_ar


def main():
    seed = random.randrange(sys.maxint)
    rng = random.Random(seed)
    range_val = 10
    starting_val = 5
    smoothing_steps = 10
    print "creating an island"
    a = generate_random_int_array(starting_val, starting_val, range_val, True)
    for i in range(smoothing_steps):
        print "Smoothing step {} of {}".format(i+1, smoothing_steps)
        if i == 0:
            b = expand_int_array(a)
        else:
            c = expand_int_array(b)
            b = c
        if i == np.floor(smoothing_steps/2):
            halfway = c
    m, n = c.shape
    x = np.zeros((m, n))
    for i in range(m):
        x[i][:] = np.linspace(0, range_val, n)
    y = np.transpose(x)
    fig = plt.figure()
    # ax = fig.add_subplot(121, projection='3d')
    # ax.plot_wireframe(x, y, c)
    ax = fig.add_subplot(131)
    ax.imshow(a, cmap='gist_earth')
    plt.title("Original random array")
    ax1 = fig.add_subplot(132)
    ax1.imshow(halfway, cmap='gist_earth')
    plt.title("Halfway through smoothing")
    plt.xlabel("Island generated by seed: {}".format(seed))
    ax2 = fig.add_subplot(133)
    ax2.imshow(c, cmap='gist_earth')
    plt.title("Final result")
    plt.show()
    save_to_file(c, 'savefile_{}_{}_{}_{}'.format(starting_val, range_val, smoothing_steps, seed))
    print "done"

def save_to_file(a, filename):
    np.save(filename, a)

def load_from_file(filename):
    return np.load(filename)

if __name__ == "__main__":
    main()

# TODO add some Gaussian smoothing to the edges of the final island
# TODO consider stacking this with Perlin noise generation for more interesting features (caves and such)
# TODO expand to also be able to create cylindrical and spherical worlds
# TODO add preset functions to generate islands, dual peeks, other landmasses
# TODO add 3D rendering with OpenGL or Blender?
# TODO add wave simulations to 3D rendering
# TODO add river formation with brownian motion